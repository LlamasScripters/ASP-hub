name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      tag:
        description: "Image tag to deploy"
        required: false
        default: "latest"

env:
  REGISTRY: ghcr.io
  GITHUB_ORG: llamasscripters
  CLIENT_IMAGE_NAME: ${{ github.repository }}-client
  SERVER_IMAGE_NAME: ${{ github.repository }}-server
  STACK_NAME: asphub
  NODE_VERSION: "22.15.0"

jobs:
  quality-checks:
    name: Quality Checks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: |
            ./package-lock.json
            ./client/package-lock.json
            ./server/package-lock.json

      - name: Install root dependencies
        run: npm ci

      - name: Install client dependencies
        working-directory: ./client
        run: npm ci

      - name: Install server dependencies
        working-directory: ./server
        run: npm ci

      - name: Run lint checks
        run: npm run lint

      - name: Run client typecheck
        working-directory: ./client
        run: npm run typecheck

      - name: Run server typecheck
        working-directory: ./server
        run: npm run typecheck

      - name: Run client tests
        working-directory: ./client
        run: npm run test

  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: quality-checks
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.meta.outputs.tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.GITHUB_ORG }}
          password: ${{ secrets.ORG_GITHUB_TOKEN }}

      - name: Generate image metadata
        id: meta
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.tag }}" ]]; then
            TAG="${{ github.event.inputs.tag }}"
          else
            TAG="latest"
          fi
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "client-image=${{ env.REGISTRY }}/${{ env.CLIENT_IMAGE_NAME }}:${TAG}" >> $GITHUB_OUTPUT
          echo "server-image=${{ env.REGISTRY }}/${{ env.SERVER_IMAGE_NAME }}:${TAG}" >> $GITHUB_OUTPUT

      - name: Build and push client image
        uses: docker/build-push-action@v5
        with:
          context: ./client
          target: production
          push: true
          tags: |
            ${{ steps.meta.outputs.client-image }}
            ${{ env.REGISTRY }}/${{ env.CLIENT_IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Build and push server image
        uses: docker/build-push-action@v5
        with:
          context: ./server
          target: production
          push: true
          tags: |
            ${{ steps.meta.outputs.server-image }}
            ${{ env.REGISTRY }}/${{ env.SERVER_IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install SSH key
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          name: id_ed25519
          known_hosts: ${{ secrets.SSH_KNOWN_HOSTS }}

      - name: Setup Docker context
        run: |
          docker context create production --docker "host=ssh://${{ secrets.PRODUCTION_HOST }}"
          docker context use production

      - name: Verify Docker connection
        run: |
          docker info --format '{{.Name}} - {{.ServerVersion}}'

      - name: Update stack services
        run: |
          # Update client service
          docker service update \
            --image ${{ env.REGISTRY }}/${{ env.CLIENT_IMAGE_NAME }}:${{ needs.build-and-push.outputs.image-tag }} \
            --with-registry-auth \
            ${{ env.STACK_NAME }}_client || echo "Client service not found, will be created during stack deploy"

          # Update server service
          docker service update \
            --image ${{ env.REGISTRY }}/${{ env.SERVER_IMAGE_NAME }}:${{ needs.build-and-push.outputs.image-tag }} \
            --with-registry-auth \
            ${{ env.STACK_NAME }}_server || echo "Server service not found, will be created during stack deploy"

      - name: Verify deployment
        run: |
          echo "Waiting for services to stabilize..."
          sleep 30

          # Check service status
          docker service ls --filter name=${{ env.STACK_NAME }}

          # Verify services are running
          for service in client server postgres minio; do
            if docker service ps ${{ env.STACK_NAME }}_${service} --filter "desired-state=running" --format "table {{.Name}}\t{{.CurrentState}}" | grep -q "Running"; then
              echo "✅ Service ${{ env.STACK_NAME }}_${service} is running"
            else
              echo "❌ Service ${{ env.STACK_NAME }}_${service} is not running"
              docker service ps ${{ env.STACK_NAME }}_${service} --no-trunc
            fi
          done

      - name: Run health checks
        run: |
          # Wait for application to be ready
          echo "Waiting for application health checks..."
          sleep 60

          # Check if main application is responding
          docker context use production
          if docker exec $(docker ps -q -f name=${{ env.STACK_NAME }}_server) curl -f http://localhost:3000/health 2>/dev/null; then
            echo "✅ Server health check passed"
          else
            echo "❌ Server health check failed"
            docker service logs ${{ env.STACK_NAME }}_server --tail 50
            exit 1
          fi

      - name: Cleanup Docker context
        if: always()
        run: |
          docker context use default
          docker context rm production || true
